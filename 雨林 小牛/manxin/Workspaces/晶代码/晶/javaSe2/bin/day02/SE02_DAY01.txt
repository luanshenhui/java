JAVA的异常处理机制
java对于异常的定义的结构是
Throwable类
派生出两个子类
Error与Exception

Error：系统级别出现的错误，通常是JVM出现的异常，这类错误是程序不可控的。

Exception:程序级别的错误。通常我们称为叫做异常。这一类问题是可以通过程序解决的。

java中解决异常的步骤:
发现异常，捕获异常，解决异常。

try语句
语法格式:
try{
   可能出现错误的代码片段
}

catch语句
用于捕获try中出现的异常，并实现解决方式
try{

}catch(Exception_type e){
   解决异常的代码片段
}

catch语句可以出现多次。catch中列举的异常类型应本着子类在先父类在后的原则。catch语句要出现在try语句之后。

throw语句
主动抛出异常。
语法
//e为某个异常的实例
throw e; 

使用throw主动抛出异常的情况:
1:分清责任。当调用该方法去处理问题的过程中出现错误，往往我们会将错误抛出，因为调用方有着决策上的权力。我们应当通知在这个环节出现的错误，以便调用方捕获并解决。

2:执行逻辑的过程中，出现了一个符合语法规则但是不符合业务逻辑要求的情况时，我们也可以当做异常去处理，这时我们也会主动抛出一个异常。

throws声明
throws用于声明方法要抛出的异常类型。
调用被throws声明的方法时，需要强制捕获该方法声明的抛出的异常。

通常在方法中，我们使用throw主动抛出的异常类型都要声明在throws中。
只有RuntimeException及其子类异常在throw抛出时，方法不需要将其异常类型定义在throws中。
RuntimeException及其子类属于非检查异常，指的是在编译期间，不检查这类异常的捕获。
常见的RuntimeException的子类
NullPointerException
ArrayIndexOutofBoundsException
ClassCastException
NumberFormatException
参看一下API.

throw与throws的区别？

finally块

finally块的语法:
finally{
   代码片段
}
finally块可以出现在try语句块之后，或者最后一个catch语句块之后。且只能出现一次。

finally块无论程序是否出错，都会执行其内容。无条件一定执行。
通常，我们的程序中，无论是否报错，都要执行的代码应该放在finally中，保证可以执行到。

重写方法时的异常处理
如果在继承一个类时，父类的方法声明了throws抛出指定异常，那么子类在重写该方法是应注意:
1:可以不指定throws
2:可以throws父类方法异常的子类异常
3:可以throws父类throws的部分异常

但是不能：
1:throws父类方法throws的父类异常
2:thrwos父类方法中没有throws的异常
java I/O

java对于操作系统中文件系统的支持。

File类
用于描述文件系统中的一个文件或目录。

File类的功能:
我们通过File可以获取文件或目录的名字，大小，修改日期等信息。但是不能对文件内容进行访问。

File的方法:
String getName()
获取文件或目录的名字

long length()
获取文件的大小 以字节为单位

long lastModified()
获取文件的最后修改时间  毫秒值

String getPath()
获取当前文件或目录的路径，以字符串形式返回

boolean exists()
判断当前File对象描述的文件或目录是否存在

boolean isFile()
判断当前File对象描述的是否为一个文件

boolean isDirectory()
判断当前File对象描述的是否为一个目录

boolean canRead()
判断当前文件是否可读

boolean canWrite()
判断当前文件是否可写

通过File创建文件或目录
boolean mkdir()
创建File描述的目录。

boolean createNewFile()
创建File描述的文件

boolean mkdirs()
创建目录，同时创建所有不存在的上级目录

在创建多级目录时，应选取使用mkdirs()方法，若在多级目录下创建文件，应先确保该文件所处的目录存在后，在创建文件。

删除文件或目录
boolean delete()
删除文件或目录
删除目录时要注意，要确保该目录下没有任何子项才可以成功删除目录。

查看目录下的内容
File[] listFiles()
获取当前目录下的所有子项，每一个子项用用一个File对象描述，最终以数组形式返回。

String[] list()
返回当前目录下子项的名字

练习:
   给定一个File对象，若是目录，输出该目录下的所有子项，子项若是目录，同样递归输出其子项

重载的listFiles()方法
可以传入一个过滤器，用来返回当前目录下满足过滤器要求的所有子项。

File[] listFiles(FileFilter filter)

FileFilter过滤器
是一个接口，我们需要实现该接口，并实现其中的一个抽象方法accept()
boolean accept(File file)
重写该方法的目的是定义过滤条件，返回true表示给定的file是满足条件的。

RandomAccessFile
可以读写文件内容

文件模型
 硬盘中保存的数据都是byte by byte的
 字节挨着字节

读写数据
 读写数据都是基于字节形式的。

读写完毕后，要关闭RandomAccessFile
释放对文件的操作，以及资源。

通常涉及到IO的操作，都应当捕获异常。 

RandomAccessFile的读写数据方法

创建RandomAccessFile的实例

RandomAccessFile raf = 
       new RandomAccessFile(file,"rw");
参数1:要进行读写的操作的文件对象
参数2:读写模式 
       -- "rw" : 读写
       -- "r"  :  只读
 
写操作:
    write(int d)
    向文件中写入一个字节，写入的是给定的int值的"低8位"二进制

写基本类型数据
writeInt(int a)
连续写4个字节，将给定的int值写入文件

writeLong(long l)


write(byte[] b)
将数组中的所有字节写入文件

write(byte[] b ,int offset,int len)
从字节数组中offset出开始，连续写len个字节到文件中
byte[] b = {0,1,2,3,4,5,6,7,8,9}
.
-src
--day01
---XXX.java
---XXX.java
--day02
---






