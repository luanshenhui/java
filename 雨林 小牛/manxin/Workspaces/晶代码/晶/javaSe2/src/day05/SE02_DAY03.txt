用于读写java对象的高级流

ObjectInputStream
用于将字节数据读取后转换为java对象
对象反序列化过程

ObjectOutputStream
用于将一个java中的对象转换为相应的字节并写出。
对象序列化过程


多线程
java的其中一个优势就是处理多线程简单

多线程，同时间运行多个任务。

对于操作系统而言，同时运行的每一个任务就是一个应用程序。
对于操作系统级别同时运行的任务，成为进程。
对于一个应用程序而言，同时运行的任务称为一个线程

多线程是并发运行的
所谓并发操作，就是每个任务都是走走停停的，CPU分配时间片段来运行一个任务时，
其他任务就处于暂停状态。CPU尽可能的均匀运行所有的任务，
这种在宏观上看起来是同时运行，而微观角度上是走走停停的现象叫做并发

创建线程有两种方法  一种是继承Thread类  一种是实现runnable接口

java中的多线程
Thread类
Thread类的实例表示一个线程。
我们要是想并发执行任务，则可以继承该类，并重写run方法来定义并发执行的任务逻辑，
从而达到并发操作的目的。

创建线程的第二种方式
将线程与线程要执行的任务分离开。

定义线程任务
Runnable接口
定义线程体只需要实现Runnable接口，并重写run方法。

线程运行原理:
创建线程并指派任务后，调用start()方法启动线程，这时会将该线程纳入线程调度机制。
被纳入线程调度机制的线程会被分配CPU时间片段，得以并发运行。分配时间片段时，
CPU运行该线程的任务，当时间片用完后，该任务暂停，这样走走停停。直到线程任务执行完毕，
线程退出。并被垃圾回收机制释放。

并发与葛大爷
葛大爷同时拍了3部戏。
葛大爷    CPU
经纪人    线程调度机制
剧组      线程
档期      时间片段

线程常用方法
void start() 启动线程的方法

static void yield()
让当前处于运行的线程主动放弃当次CPU时间，进入Runnable状态。

static void sleep(long time)
使当前线程进入睡眠阻塞(sleep block)，时间为给定的time描述的毫秒值。当时间超过后，
会自动回到runnable状态。

void interrupt()
中断线程

final void setPriority(int p)
设置线程的优先级
理论上，优先级越高的线程，获取CPU运行的机会多。但这不是可控的。优先级1-10
1最低，10最高,线程默认优先级为5

final void join()
等待该线程终止

守护线程(后台线程)
当一个进程中，所有的前台线程都结束时，无论守护线程是否结束，都会强制停止。并使得进程结束。
当一个进程中所有前台线程结束，进程结束

后台线程是通过线程的方法设置的。
setDaemon(boolean b)
当参数为true时，这个线程就是后台线程了。
该方法要在调用start()方法前调用才有效！

线程名字。setDaemon（true）；
线程名字。start（）；

多线程安全问题
当多个线程操作同一段数据时，可能会出现线程安全问题。这时，
我们应将操作共享数据的代码编程同步访问方式，就是要有先后的执行顺序，而不是同时执行。



线程安全锁，用于解决线程安全问题。
synchronized关键字

synchronized可以修饰方法，使得方法不可能同时由两个以上线程执行
synchronized修饰方法法时，当一个线程访问该方法时，首先会检查这个方法所属的对象是否被上锁:
1:没有上锁则对该对象上锁，然后执   行方法体。
2:若上锁，则在方法外等待，直到该   对象   的锁被其他线程释放后，执行1

也可以修饰代码片段

synchronized(同步监视器){
  需要同步的代码片段
}

通常在编写代码的时候，要分析可能出现线程安全问题的代码片段，然后使用同步块的形式对这段代码片段加锁，而不是对整个方法加锁。这样可以提高代码的运行效率。

注意:
synchronized(同步监视器)
这里的同步监视器对象要保证多个线程看到的是同一个对象，否则不具备同步效果。

线程安全与不安全的类

线程安全的             线程不安全的
StringBuffer           StringBuilder

Vector		   ArrayList

Hashtable	   HashMap


Collections类提供了用于获取线程安全集合的方法

Collections.synchronizedList(List list)
将给定的List集合转换为一个线程安全的集合

Collections.synchronizedSet(Set set)

Collections.synchronizedMap(Map map)

Object定义的关于线程操作的方法
wait()
当一个线程调用了某个对象的wait()方法时，该线程进入等待阻塞。这个阻塞不会自动取消。
只有当这个对象的notify()方法被调用，才会取消该线程的等待阻塞，回到runnable状态。

notify()
解除一个在当前对象身上等待的线程的等待阻塞，使其回到runnable状态


notifyAll()
当有多个线程在当前对象上等待，调用该方法可以将所有线程解除等待阻塞，
回到runnable状态。









