Object类：
	需要被覆盖的方法：
	1.public String toString();	//输出对象时调用
	
	2.public boolean equals(Object o);	//比较两个对象时调用
		  1.验证比较对象是否为null
		  2.验证比较对象的类型是否匹配
		  3.自定义的比较方式
		 	Object o instanceof Card	//检验o指向的类型是否是Card	
		 	
	3.public int hashCode();	//返回对象的特征码(散列码),配合equals用
	
抽象类、接口：
	1.抽象类：
		a.用abstract关键字修饰的类
		b.抽象类无法实例化，无法创建对象
		c.抽象类中可以有抽象方法
			抽象方法：只有方法的修饰和方法的签名，没有方法体
			public abstract int add();
			抽象方法只能定义在抽象类中
		d.抽象类存在的意义就是被继承
		e.抽象类定义了类的规范
		f.抽象类中的抽象方法，必须被覆盖
	
	2.接口：
		a.用interface声明
		b.接口中所有的方法都必须是抽象方法
		c.接口中所有的成员变量都必须是常量(不能定义静态)
		d.接口存在的意义是定义某种规范，只有被实现(implements)才能使用
		e.接口被实现之后，必须覆盖所有的抽象方法
		f.同一个类可以同时实现多个接口,每个接口之间用","链接
		
内部类：
	1.成员内部类：
		直接将类定义在其他类的内部,在外部类中,内部类和普通类一样,但是在其他类中,这个内部类只能通过它的外部类来创建实例,
		内部类语法存在的意义就是为了体现更好的封装。例如：食物类，游戏类中的食物类
		
	2.静态成员内部类：
		基本功能跟成员内部类一样，同时又多了静态static的特征
		
	3.局部内部类：
		将类定义在方法的内部，局部内部类的声明周期只在方法的内部，不常用
		
	4.匿名内部类：
		创建某个类的匿名子类，一般用来创建抽象类或者接口的实例。
		当某个抽象类或接口，只需要使用一次而已，那么没有必要创建一个单独的文件，这时我们使用匿名内部类来实例化这个接口或抽象类
		匿名内部类相当于这个抽象类或接口的子类，必须覆盖其中所有的抽象方法。
	
	
	
	
	
	
	